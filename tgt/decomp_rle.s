;
; File generated by cc65 v 2.18 - Git 2f3955d
;
	.fopt		compiler,"cc65 v 2.18 - Git 2f3955d"
	.setcpu		"65C02"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_decomp_rle

.segment	"BSS"

_in = ptr2
_out = ptr3
_orig = ptr4
_wrote = ptr1
_cur = ptr1+1
_buf = tmp1
_n = tmp2
_prev = tmp3
_run = tmp4

; ---------------------------------------------------------------
; void __near__ get (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_get: near

;
; if (!n) {
;   buf = *in++;
;   cur = buf & 15;
;   buf >>= 4;
;   n = 1;
;  } else {
;   cur = buf & 15;
;   n = 0;
;  }
;
	lda     _n
	bne     L0002

	lda	(_in)
	tay
	and     #$0F
	sta     _cur

	inc	_in
	bne	@noinc
	inc	_in+1
@noinc:
	tya
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     _buf

	lda     #$01
	bra     L005C

L0002:	lda     _buf
	and     #$0F
	sta     _cur
	lda     #$00
L005C:	sta     _n

	rts

.endproc

; ---------------------------------------------------------------
; u8 decomp_rle(const u8 *in, u8 *out);
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_decomp_rle: near

	sta	_out
	sty	_out+1

	jsr	popax
	sta	_in
	sta	_orig
	stx	_in+1
	stx	_orig+1
;
; orig = in;
;
;
; wrote = n = 0;
;
	stz     _wrote
	stz     _n
;
; prev = buf = *in++;
; prev &= 15;
;
	lda	(_in)
	tay
	and     #$0F
	sta	_prev
	inc	_in
	bne	@noinc
	inc	_in+1
@noinc:
;
; buf >>= 4;
;
	tya
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     _buf
;
; n = 1;
;
	lda     #$01
	sta     _n
;
; get();
;
L0023:	jsr     _get
;
; if (cur != prev) {
;
	lda     _prev
	cmp     _cur
	beq     L0028
;
; *out++ = prev;
;
	lda	_prev
	sta	(_out)
	inc	_out
	bne	@noinc
	inc	_out+1
@noinc:
;
; wrote++;
;
	inc     _wrote
;
; if (wrote == 63) {
;
	lda     _wrote
	cmp     #$3F
	bne     L005F
;
; *out++ = cur;
;
	lda	_cur
	sta	(_out)
	inc	_out
	bne	:+
	inc	_out+1
:
;
; break;
;
	bra     L0024
;
; prev = cur;
;
L005F:	lda     _cur
	sta     _prev
;
; } else {
;
	bra     L0023
;
; get();
;
L0028:	jsr     _get
;
; run = cur;
;
	lda     _cur
;
; while (cur == 15) {
;
	bra     L005E
;
; get();
;
L003A:	jsr     _get
;
; run += cur;
;
	lda     _cur
	clc
	adc     _run
L005E:	sta     _run
;
; while (cur == 15) {
;
	lda     _cur
	cmp     #$0F
	beq     L003A
;
; run += 2;
;
	inc	_run
	inc	_run
;
; for (i = 0; i < run; i++) {
;
	ldx	#0
L0060:
	cpx     _run
	bcs     L0061
;
; *out++ = prev;
;
	lda	_prev
	sta	(_out)
	inc	_out
	bne	:+
	inc	_out+1
:
;
; for (i = 0; i < run; i++) {
;
	inx
	bra     L0060
;
; wrote += run;
;
L0061:	lda     _run
	clc
	adc     _wrote
	sta     _wrote
;
; if (wrote == 64)
;
	cmp     #$40
;
; break;
;
	beq     L0024
;
; get();
;
	jsr     _get
;
; prev = cur;
;
	lda     _cur
	sta     _prev
;
; if (wrote == 63) {
;
	lda     _wrote
	cmp     #$3F
	jne     L0023
;
; *out++ = cur;
;
	lda	_cur
	sta	(_out)
	inc	_out
	bne	:+
	inc	_out+1
:
;
; wrote++;
;
	inc     _wrote
;
; return in - orig;
;
L0024:	lda     _in
	sec
	sbc     _orig
	ldx     #$00

	rts

.endproc

