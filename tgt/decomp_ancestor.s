;
; File generated by cc65 v 2.18 - Git 2f3955d
;
	.fopt		compiler,"cc65 v 2.18 - Git 2f3955d"
	.setcpu		"65C02"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		_decomp_ancestor
	.importzp	passin, passout

_in = passin
_out = passout
_src = ptr4 ; share the area, they don't overlap
_val = ptr4 ;
_summary = tmp2
_origin = ptr1
_dist = regsave

; ---------------------------------------------------------------
; u8 decomp_ancestor(const u8 *in, u8 *out);
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_decomp_ancestor: near

	lda	_out
	sta	_src
	ldx	_out+1
	stx	_src+1

	lda	_in
	sta	_origin
	ldx	_in+1
	stx	_origin+1

	lda	_mbyte
	sta	_summary
;
; src = out;
; origin = in;
;
;
; dist = 0;
;
	stz     _dist
	stz     _dist+1
;
; i = *in++;
;
L0008:	lda     (_in)
	sta	tmp1
	inc	_in
	bne	:+
	inc	_in+1
:
;
; dist += i;
;
	clc
	adc     _dist
	sta     _dist
	lda     #$00
	adc     _dist+1
	sta     _dist+1
;
; } while (i == 255);
;
	lda     tmp1
	cmp     #$FF
	beq     L0008
;
; dist++;
;
	inc	_dist
	bne	:+
	inc	_dist+1
:
;
; src -= 32 * dist;
;
	lda     _dist
	ldx     _dist+1
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	eor     #$FF
	sec
	adc     _src
	sta     _src
	lda     tmp1
	eor     #$FF
	adc     _src+1
	sta     _src+1
;
; memcpy(out, src, 32);
;
	ldy	#31
@loop:	lda	(_src),y
	sta	(_out),y
	dey
	bpl	@loop
;
; val = in;
;
	lda     _in+1
	sta     _val+1
	lda     _in
	sta     _val
;
; if (summary & 1)
;
	lda     _summary
	and     #$01
	beq     L004D
;
; in++;
;
	inc	_in
	bne	:+
	inc	_in+1
:
;
; if (summary & 2)
;
L004D:	lda     _summary
	and     #$02
	beq     L004E
;
; in++;
;
	inc	_in
	bne	:+
	inc	_in+1
:
;
; if (summary & 4)
;
L004E:	lda     _summary
	and     #$04
	beq     L004F
;
; in++;
;
	inc	_in
	bne	:+
	inc	_in+1
:
;
; if (summary & 8)
;
L004F:	lda     _summary
	and     #$08
	beq     L0051
;
; in++;
;
	inc	_in
	bne	:+
	inc	_in+1
:
;
; for (s = 0; s < 4; s++) {
;
L0051:	ldx	#0
L0052:
	cpx     #$04
	jcs     L002C
;
; if (summary & 1 << s) {
;
	lda	_summary
	and	#1
	jeq     L0033
;
; for (i = 0; i < 8; i++) {
;
	lda	(_val)
	sta	tmp1

	ldy	#0
L0053:
	cpy     #$08
	bcs     L0036
;
; if (*val & 1 << i)
;
	lsr	tmp1
	bcc     L003D
;
; *out++ = *in++;
;
	lda	(_in)
	sta	(_out)
	inc	_in
	bne	:+
	inc	_in+1
:
L003D:
	inc	_out
	bne	:+
	inc	_out+1
:
;
; for (i = 0; i < 8; i++) {
;
L0054:	iny
	bra     L0053
;
; val++;
;
L0036:	inc	_val
	bne	:+
	inc	_val+1
:
;
; } else {
;
	bra     L002D
;
; out += 8;
;
L0033:	lda     #$08
	clc
	adc     _out
	sta     _out
	bcc     L002D
	inc     _out+1
;
; for (s = 0; s < 4; s++) {
;
L002D:	inx
	lsr	_summary
	jmp     L0052
;
; return in - origin;
;
L002C:	lda     _in
	sec
	sbc     _origin
	ldx     #$00

	rts

.endproc
